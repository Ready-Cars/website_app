<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Anambra Map Editor — Full (pan toggle, undo/redo, snap, auto-trace)</title>
    <style>
        :root{
            --highlight:#f4f86b;
            --panel-w:420px;
            --maxw:1400px;
        }
        *{box-sizing:border-box}
        html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;color:#eaf0f2;background:#0b0d0f}
        .container{max-width:var(--maxw);margin:14px auto;padding:14px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 12px 40px rgba(0,0,0,.6);display:grid;grid-template-columns:1fr var(--panel-w);gap:14px;align-items:start}
        .map-wrap{position:relative;border-radius:10px;overflow:hidden;min-height:680px;background:#000;touch-action:none}
        .bg-img{width:100%;height:100%;object-fit:cover;display:block;filter:blur(0.3px) saturate(.95) brightness(.92);pointer-events:none}
        .svg-overlay{position:absolute;inset:0;pointer-events:auto}
        svg{width:100%;height:100%;display:block}
        .region{fill:rgba(255,255,255,0.95);stroke:rgba(0,0,0,0.7);stroke-width:2;cursor:pointer;transition:all .12s}
        .region:hover{transform:translateY(-4px)}
        .region.active{fill:var(--highlight);filter:drop-shadow(0 12px 18px rgba(244,248,107,0.16))}
        .vertex{fill:#fff; stroke:#333; stroke-width:1; r:6; cursor:pointer; display:none}
        .vertex.show{display:inline}
        .ui-panel{padding:14px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03);min-height:220px}
        .ui-panel h2{margin:2px 0 12px 0;font-size:18px;color:#fff}
        .info{font-size:13px;color:rgba(230,235,236,0.95);line-height:1.55}
        .controls{margin-top:12px;display:flex;gap:8px;flex-wrap:wrap}
        button, .btn{background:#0f1720;border:1px solid rgba(255,255,255,0.04);color:#eaf3f5;padding:8px 10px;border-radius:8px;cursor:pointer}
        .btn.primary{background:var(--highlight);color:#0b2315;font-weight:700}
        .list{margin-top:10px;max-height:220px;overflow:auto;padding-right:6px}
        .region-item{padding:8px;border-radius:8px;margin-bottom:6px;background:rgba(255,255,255,0.02);display:flex;justify-content:space-between;align-items:center}
        .small{font-size:12px;color:rgba(220,225,227,0.7)}
        .editor-help{margin-top:12px;font-size:12px;color:rgba(220,225,227,0.7)}
        input[type="text"], textarea, select{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#fff}
        .bottom-row{display:flex;gap:8px;margin-top:12px}
        .notice{font-size:13px;color:rgba(200,210,211,0.85);margin-top:8px}
        .kbd{display:inline-block;padding:2px 6px;border-radius:6px;background:rgba(255,255,255,0.06);font-weight:700;margin-left:6px}
        .row{display:flex;gap:8px;align-items:center}
        .small-muted{font-size:12px;color:rgba(200,210,211,0.7)}
        @media (max-width:980px){.container{grid-template-columns:1fr;padding:10px}.ui-panel{order:2}}
    </style>
</head>
<body>
<div class="container" role="application" aria-label="Anambra full map editor">
    <div class="map-wrap" id="mapWrap">
        <img id="bgImg" class="bg-img" src="/mnt/data/5124b71a-3c3c-4882-bbf8-261d3c919da5.png" alt="Anambra map">
        <div class="svg-overlay" id="svgOverlay" aria-hidden="false"></div>
        <!-- hidden canvas for edge detection -->
        <canvas id="edgeCanvas" width="1000" height="1000" style="display:none"></canvas>
    </div>

    <aside class="ui-panel" id="panel">
        <h2>Anambra Map — Full Editor</h2>
        <div class="info" id="info">
            Use the controls below. <strong>Pan</strong> via Space or middle-button, or use the on-screen pan toggle. <strong>Snap to edges</strong> helps align vertices to strong image contours.
        </div>

        <div class="controls" style="margin-top:12px">
            <button id="toggleEditBtn">Enter Edit Mode</button>
            <button id="togglePanBtn">Pan: Off</button>
            <button id="undoBtn" title="Undo">↶ Undo</button>
            <button id="redoBtn" title="Redo">↷ Redo</button>
        </div>

        <div style="margin-top:8px" class="row">
            <button id="addRegionBtn">Add Region</button>
            <button id="downloadJsonBtn" class="btn primary">Download JSON</button>
        </div>

        <div style="margin-top:8px" class="row">
            <button id="snapToggle" class="">Snap: Off</button>
            <button id="refineBtn">Refine (snap all)</button>
            <button id="autotraceBtn">Auto-trace (attempt)</button>
        </div>

        <div class="notice" id="editNotice" style="display:none;margin-top:10px">
            <strong>Edit Mode:</strong> Click map to add vertices. Press <kbd>Enter</kbd> to finish polygon. Drag vertices to adjust. Click inside selected polygon and drag to move the region. <br>
            <span class="small-muted">Refine will snap vertices to nearest strong edge produced by internal Sobel filter.</span>
        </div>

        <div class="list" id="regionList" style="margin-top:12px"></div>

        <div style="margin-top:12px">
            <label class="small">Region name</label>
            <input id="regionName" type="text" placeholder="Region title..." />
            <label class="small" style="margin-top:8px">Description (HTML allowed)</label>
            <textarea id="regionDesc" rows="4" placeholder="Short description for the region..."></textarea>

            <div class="bottom-row">
                <button id="saveChangesBtn">Save changes</button>
                <button id="deleteRegionBtn" style="background:#3b1111;border:1px solid rgba(255,255,255,0.03)">Delete region</button>
            </div>
        </div>

        <div class="editor-help">
            <div><strong>Tips</strong></div>
            <ul style="padding-left:18px;margin:6px 0 0 0;color:rgba(220,225,227,0.7)">
                <li>When snapping is on, vertex drags will snap to the nearest strong edge within radius.</li>
                <li>Auto-trace produces a best-effort contour using strong edge points inside the selected polygon (use as starting point).</li>
                <li>Use Undo/Redo liberally — all edits are recorded.</li>
            </ul>
        </div>
    </aside>
</div>

<script>
    /* Full editor script:
       - pan toggle UI
       - undo/redo stack
       - sobel edge detection & snap/refine/auto-trace
       - existing features: draw, drag vertex, move region, load/save
    */

    // ---- Config ----
    const VIEW_SIZE = 1000; // SVG viewBox 0..1000
    const EDGE_THRESHOLD = 100; // gradient magnitude threshold for edges (0..~1024)
    const SNAP_RADIUS = 18; // pixels (in SVG coords) search radius for snapping
    const AUTO_TRACE_RESAMPLE = 200; // approx number of points to sample when building contour

    // ---- State ----
    let data = null;
    const svgNS = "http://www.w3.org/2000/svg";
    let svg = null, transformGroup = null, polygonsGroup = null, verticesGroup = null;
    let editMode = false;
    let drawing = false, currentPoints = [], currentPolyEl = null;
    let activeRegionId = null;
    let pan = {x:0,y:0}, scale = 1.0;
    let isPanning = false, panStart = null;
    let movingRegion = false, moveStart = null, moveOriginalPoints = null;
    let draggingVertex = null;
    let snapEnabled = false;
    let panToggleOn = false;

    // undo/redo stacks (store deep snapshots of data + pan/scale)
    const undoStack = [];
    const redoStack = [];
    function pushUndo(label){
        // snapshot important bits
        const snap = {
            data: JSON.parse(JSON.stringify(data)),
            pan: {...pan},
            scale: scale,
            activeRegionId: activeRegionId,
            label
        };
        undoStack.push(snap);
        // cap stack size
        if(undoStack.length > 80) undoStack.shift();
        // clear redo on new action
        redoStack.length = 0;
        updateUndoRedoButtons();
    }
    function applySnapshot(snap){
        if(!snap) return;
        data = JSON.parse(JSON.stringify(snap.data));
        pan = {...snap.pan};
        scale = snap.scale;
        activeRegionId = snap.activeRegionId;
        drawPolygons();
        applyTransform();
        populateInfoPanel();
    }
    function undo(){
        if(undoStack.length === 0) return;
        const snap = undoStack.pop();
        redoStack.push({
            data: JSON.parse(JSON.stringify(data)),
            pan: {...pan},
            scale, activeRegionId
        });
        applySnapshot(snap);
        updateUndoRedoButtons();
    }
    function redo(){
        if(redoStack.length === 0) return;
        const snap = redoStack.pop();
        undoStack.push({
            data: JSON.parse(JSON.stringify(data)),
            pan: {...pan},
            scale, activeRegionId
        });
        applySnapshot(snap);
        updateUndoRedoButtons();
    }
    function updateUndoRedoButtons(){
        document.getElementById('undoBtn').disabled = undoStack.length === 0;
        document.getElementById('redoBtn').disabled = redoStack.length === 0;
    }

    // ---- Edge detection ----
    const edgeCanvas = document.getElementById('edgeCanvas');
    const edgeCtx = edgeCanvas.getContext('2d', {willReadFrequently:true});
    let edgeMap = null; // Uint8ClampedArray of gradient magnitudes (0..255)
    let edgePoints = []; // [{x,y,mag}] in VIEW coords
    async function buildEdgeMap(){
        // draw image into canvas sized to VIEW_SIZE to match SVG space
        const img = document.getElementById('bgImg');
        // ensure canvas size
        edgeCanvas.width = VIEW_SIZE;
        edgeCanvas.height = VIEW_SIZE;
        // draw image to canvas stretched to fit VIEW_SIZE
        edgeCtx.clearRect(0,0,edgeCanvas.width,edgeCanvas.height);
        // Wait for image load if not ready
        if(!img.complete){
            await new Promise(res => img.onload = res);
        }
        // draw with cover-like behavior: compute aspect fit center-crop
        const cw = edgeCanvas.width, ch = edgeCanvas.height;
        const iw = img.naturalWidth, ih = img.naturalHeight;
        // compute scale to cover
        const scaleCover = Math.max(cw/iw, ch/ih);
        const dw = iw * scaleCover, dh = ih * scaleCover;
        const dx = (cw - dw)/2, dy = (ch - dh)/2;
        edgeCtx.drawImage(img, dx, dy, dw, dh);

        const imgData = edgeCtx.getImageData(0,0,cw,ch);
        const gray = new Float32Array(cw*ch);
        // grayscale
        for(let y=0;y<ch;y++){
            for(let x=0;x<cw;x++){
                const i = (y*cw + x)*4;
                const r = imgData.data[i], g = imgData.data[i+1], b = imgData.data[i+2];
                const lum = 0.299*r + 0.587*g + 0.114*b;
                gray[y*cw + x] = lum;
            }
        }
        // sobel kernels
        const w = cw, h = ch;
        edgeMap = new Uint8ClampedArray(w*h);
        edgePoints = [];
        const kx = [-1,0,1,-2,0,2,-1,0,1];
        const ky = [-1,-2,-1,0,0,0,1,2,1];
        for(let y=1;y<h-1;y++){
            for(let x=1;x<w-1;x++){
                let gx = 0, gy = 0, idx = 0;
                for(let kyI=-1; kyI<=1; kyI++){
                    for(let kxI=-1; kxI<=1; kxI++){
                        const sample = gray[(y+kyI)*w + (x+kxI)];
                        gx += kx[idx] * sample;
                        gy += ky[idx] * sample;
                        idx++;
                    }
                }
                const mag = Math.sqrt(gx*gx + gy*gy);
                // normalize / scale to 0..255 approximate
                const norm = Math.min(255, Math.floor((mag/500)*255));
                edgeMap[y*w + x] = norm;
                if(norm > EDGE_THRESHOLD){
                    // store as candidate edge point
                    edgePoints.push({x,y,mag:norm});
                }
            }
        }
        console.log('Edge map built, edge points:', edgePoints.length);
    }

    // find nearest edge point to (x,y) within radius (in VIEW coords)
    function nearestEdge(x,y, radius=SNAP_RADIUS){
        if(!edgePoints || edgePoints.length===0) return null;
        const r2 = radius*radius;
        let best = null;
        let bestD = Infinity;
        // brute force search (edgePoints can be thousands but VIEW_SIZE=1000 OK)
        for(let i=0;i<edgePoints.length;i++){
            const p = edgePoints[i];
            const dx = p.x - x, dy = p.y - y;
            const d2 = dx*dx + dy*dy;
            if(d2 < bestD && d2 <= r2){
                bestD = d2;
                best = p;
            }
        }
        return best;
    }

    // ---- SVG / Editor ----
    function createSvg(){
        const overlay = document.getElementById('svgOverlay');
        overlay.innerHTML = '';
        svg = document.createElementNS(svgNS,'svg');
        svg.setAttribute('viewBox', `0 0 ${VIEW_SIZE} ${VIEW_SIZE}`);
        svg.setAttribute('preserveAspectRatio','xMidYMid slice');
        overlay.appendChild(svg);

        transformGroup = document.createElementNS(svgNS,'g');
        transformGroup.setAttribute('id','transformGroup');
        svg.appendChild(transformGroup);

        polygonsGroup = document.createElementNS(svgNS,'g'); transformGroup.appendChild(polygonsGroup);
        verticesGroup = document.createElementNS(svgNS,'g'); transformGroup.appendChild(verticesGroup);

        // events
        svg.addEventListener('click', onSvgClick);
        svg.addEventListener('mousemove', onSvgMouseMove);
        svg.addEventListener('wheel', onSvgWheel, {passive:false});
        svg.addEventListener('mousedown', onSvgMouseDown);
        document.addEventListener('mouseup', onDocumentMouseUp);
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
    }

    // convert client coords to VIEW coords (taking transform into account)
    function clientToView(evt){
        const pt = svg.createSVGPoint();
        pt.x = evt.clientX; pt.y = evt.clientY;
        const ctm = svg.getScreenCTM().inverse();
        const screen = pt.matrixTransform(ctm); // coordinates in SVG space after screen CTM
        // now apply inverse of the transformGroup transform (translate pan, scale)
        const x = (screen.x - pan.x) / scale;
        const y = (screen.y - pan.y) / scale;
        return {x,y, raw: screen};
    }

    // draw polygons & vertices
    function drawPolygons(){
        polygonsGroup.innerHTML = ''; verticesGroup.innerHTML = '';
        data.regions.forEach(region => {
            const poly = document.createElementNS(svgNS,'polygon');
            poly.classList.add('region');
            poly.setAttribute('data-id', region.id);
            poly.setAttribute('points', region.points.map(p => `${p[0]},${p[1]}`).join(' '));
            poly.addEventListener('click', e => { e.stopPropagation(); if(editMode) selectRegion(region.id); else toggleActive(region.id); });
            poly.addEventListener('mousedown', e => {
                if(!editMode) return;
                if(activeRegionId === region.id){
                    e.stopPropagation();
                    startMoveRegion(e, region.id);
                }
            });
            polygonsGroup.appendChild(poly);

            // vertices
            region.points.forEach((p, idx) => {
                const c = document.createElementNS(svgNS,'circle');
                c.setAttribute('cx', p[0]); c.setAttribute('cy', p[1]); c.setAttribute('r', 6);
                c.classList.add('vertex'); c.setAttribute('data-region', region.id); c.setAttribute('data-index', idx);
                c.addEventListener('mousedown', ev => { ev.stopPropagation(); startDragVertex(c); });
                verticesGroup.appendChild(c);
            });
        });
        refreshList(); refreshActiveVisuals();
    }

    // refresh right list
    function refreshList(){
        const list = document.getElementById('regionList');
        list.innerHTML = '';
        data.regions.forEach(r => {
            const item = document.createElement('div'); item.className='region-item';
            item.innerHTML = `<div><div style="font-weight:700">${r.name||r.id}</div><div class="small">${r.id}</div></div>
      <div style="display:flex;gap:6px"><button data-id="${r.id}" class="viewBtn">View</button><button data-id="${r.id}" class="editBtn">Edit</button></div>`;
            list.appendChild(item);
        });
        list.querySelectorAll('.viewBtn').forEach(b=>b.addEventListener('click', ()=>toggleActive(b.dataset.id)));
        list.querySelectorAll('.editBtn').forEach(b=>{ b.addEventListener('click', ()=>{ enterEditMode(); selectRegion(b.dataset.id); }); });
    }

    function toggleActive(id){
        if(activeRegionId === id) activeRegionId = null; else activeRegionId = id;
        refreshActiveVisuals(); populateInfoPanel();
    }

    function selectRegion(id){
        activeRegionId = id;
        document.querySelectorAll('.vertex').forEach(v => v.classList.toggle('show', v.dataset.region === id));
        const r = data.regions.find(rr => rr.id === id);
        if(r){ document.getElementById('regionName').value = r.name || ''; document.getElementById('regionDesc').value = r.desc || ''; }
        refreshActiveVisuals(); populateInfoPanel();
    }

    function refreshActiveVisuals(){
        document.querySelectorAll('.region').forEach(el => { const id = el.getAttribute('data-id'); el.classList.toggle('active', id===activeRegionId); });
        // update vertex indices (for ordering) each draw
        Array.from(verticesGroup.querySelectorAll('circle')).forEach(c => {
            const rid = c.dataset.region; const idx = Number(c.dataset.index);
            if(data){
                const r = data.regions.find(rr => rr.id === rid);
                if(r && r.points[idx]){
                    c.setAttribute('cx', r.points[idx][0]); c.setAttribute('cy', r.points[idx][1]);
                }
            }
        });
    }

    function populateInfoPanel(){
        const info = document.getElementById('info');
        if(!activeRegionId){ info.innerHTML = 'Click a region to view details. Use Edit Mode to refine shapes.'; return; }
        const r = data.regions.find(rr => rr.id === activeRegionId);
        if(!r){ info.innerHTML = 'Region not found'; return; }
        info.innerHTML = `<div style="font-weight:700;font-size:15px;color:#fff">${r.name}</div>
                    <div style="margin-top:8px">${r.desc||'<em>No description</em>'}</div>
                    <div class="small" style="margin-top:8px">ID: ${r.id} • Points: ${r.points.length}</div>`;
    }

    // ---- Edit mode toggles ----
    function enterEditMode(){ editMode = true; document.getElementById('toggleEditBtn').textContent='Exit Edit Mode'; document.getElementById('editNotice').style.display='block'; document.querySelectorAll('.vertex').forEach(v=>v.classList.toggle('show', v.dataset.region===activeRegionId)); }
    function exitEditMode(){ editMode=false; drawing=false; currentPoints=[]; if(currentPolyEl) currentPolyEl.remove(); currentPolyEl=null; document.getElementById('toggleEditBtn').textContent='Enter Edit Mode'; document.getElementById('editNotice').style.display='none'; document.querySelectorAll('.vertex').forEach(v=>v.classList.remove('show')); }
    document.getElementById('toggleEditBtn').addEventListener('click', ()=>{ if(editMode) exitEditMode(); else enterEditMode(); });

    // ---- Add / Save / Delete / JSON ----
    document.getElementById('addRegionBtn').addEventListener('click', ()=>{
        pushUndo('add-region');
        const id = 'region-' + Math.random().toString(36).slice(2,8);
        const newR = {id, name:'New region', desc:'<p>Describe this region</p>', points:[[300,300],[360,300],[360,360],[300,360]]};
        data.regions.push(newR); drawPolygons(); selectRegion(id); enterEditMode();
    });
    document.getElementById('saveChangesBtn').addEventListener('click', ()=>{
        if(!activeRegionId) { alert('Select a region to save'); return; }
        pushUndo('edit-meta');
        const r = data.regions.find(rr=>rr.id===activeRegionId);
        if(!r) return;
        r.name = document.getElementById('regionName').value;
        r.desc = document.getElementById('regionDesc').value;
        drawPolygons(); selectRegion(activeRegionId);
    });
    document.getElementById('deleteRegionBtn').addEventListener('click', ()=>{
        if(!activeRegionId){ alert('Select region to delete'); return; }
        if(!confirm('Delete region?')) return;
        pushUndo('delete-region');
        data.regions = data.regions.filter(r=>r.id!==activeRegionId); activeRegionId = null; drawPolygons(); populateInfoPanel();
    });
    document.getElementById('downloadJsonBtn').addEventListener('click', ()=>{
        const payload = {meta:{source:'export',scale:VIEW_SIZE}, regions:data.regions};
        const blob = new Blob([JSON.stringify(payload,null,2)], {type:'application/json'});
        const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='regions.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });

    // ---- SVG interactions: draw, pan, zoom, drag vertex, move region ----
    svgEventInit();

    function svgEventInit(){ createSvg(); }

    // click on svg: drawing new polygon if in edit mode
    function onSvgClick(evt){
        if(isPanning) return;
        if(!editMode) return;
        const p = clientToView(evt);
        if(!drawing){
            drawing = true;
            currentPoints = [[p.x,p.y]];
            currentPolyEl = document.createElementNS(svgNS,'polygon'); currentPolyEl.setAttribute('class','region'); currentPolyEl.setAttribute('data-id','_drawing');
            currentPolyEl.setAttribute('points', `${p.x},${p.y}`);
            polygonsGroup.appendChild(currentPolyEl);
        } else {
            currentPoints.push([p.x,p.y]); currentPolyEl.setAttribute('points', currentPoints.map(pp=>pp.join(',')).join(' '));
        }
    }

    // mousemove: preview drawing, pan, or region move
    function onSvgMouseMove(evt){
        if(isPanning && panStart){
            evt.preventDefault();
            const dx = evt.clientX - panStart.x; const dy = evt.clientY - panStart.y;
            pan.x = panStart.origX + dx; pan.y = panStart.origY + dy;
            applyTransform();
            return;
        }
        if(drawing && currentPolyEl){
            const p = clientToView(evt);
            const pts = currentPoints.concat([[p.x,p.y]]);
            currentPolyEl.setAttribute('points', pts.map(pp=>pp.join(',')).join(' '));
        }
        if(movingRegion && moveStart){
            const p = clientToView(evt); const dx = p.x - moveStart.x, dy = p.y - moveStart.y;
            const region = data.regions.find(r=>r.id===activeRegionId);
            if(region && moveOriginalPoints){
                region.points = moveOriginalPoints.map(pt => [pt[0] + dx, pt[1] + dy]);
                const poly = polygonsGroup.querySelector(`polygon[data-id="${region.id}"]`); if(poly) poly.setAttribute('points', region.points.map(pp=>pp.join(',')).join(' '));
                // update vertices positions
                Array.from(verticesGroup.querySelectorAll('circle')).forEach(c => {
                    if(c.dataset.region === region.id){
                        const idx = Number(c.dataset.index);
                        c.setAttribute('cx', region.points[idx][0]); c.setAttribute('cy', region.points[idx][1]);
                    }
                });
            }
        }
    }

    // wheel: zoom
    function onSvgWheel(evt){
        evt.preventDefault();
        const delta = -evt.deltaY;
        const factor = (delta > 0) ? 1.08 : 0.92;
        const rawPoint = svg.createSVGPoint(); rawPoint.x = evt.clientX; rawPoint.y = evt.clientY;
        const screenToSvg = rawPoint.matrixTransform(svg.getScreenCTM().inverse());
        const prevScale = scale;
        const newScale = Math.max(0.25, Math.min(8, scale * factor));
        // adjust pan to keep mouse anchored
        const sx = screenToSvg.x, sy = screenToSvg.y;
        pan.x = sx - (newScale/prevScale) * (sx - pan.x);
        pan.y = sy - (newScale/prevScale) * (sy - pan.y);
        scale = newScale;
        pushUndo('zoom'); applyTransform();
    }

    // mousedown for pan or starting move is handled on elements; here handle pan start
    function onSvgMouseDown(evt){
        // if on-screen pan toggle is on OR space/middle button pressed -> pan
        if(panToggleOn || evt.button === 1 || evt.code === 'Space' || evt.buttons === 4 || evt.shiftKey){
            isPanning = true; panStart = {x:evt.clientX, y:evt.clientY, origX:pan.x, origY:pan.y};
            return;
        }
    }

    // document mouseup cleanup
    function onDocumentMouseUp(evt){
        // finish drawing on click outside? No - finish only on Enter
        if(isPanning){
            // record pan change as undoable
            pushUndo('pan');
            isPanning = false; panStart = null;
        }
        if(movingRegion){
            // record move complete
            movingRegion = false; moveStart = null; moveOriginalPoints = null;
            pushUndo('move-region');
        }
        endDragVertex();
        updateUndoRedoButtons();
    }

    // key handlers
    let spaceDown = false;
    function onKeyDown(evt){ if(evt.code === 'Space') spaceDown = true; if(evt.key==='Enter' && drawing){ // finalize polygon
        evt.preventDefault();
        const id = prompt('Enter id (no spaces):', 'region-' + Math.random().toString(36).slice(2,6));
        if(!id){ drawing=false; if(currentPolyEl) currentPolyEl.remove(); currentPolyEl=null; currentPoints=[]; return; }
        const name = prompt('Name:', id) || id; const desc = prompt('Description (HTML ok):','') || '';
        pushUndo('finish-draw');
        data.regions.push({id, name, desc, points: currentPoints.slice()});
        drawing = false; currentPoints=[]; if(currentPolyEl) currentPolyEl.remove(); currentPolyEl=null;
        drawPolygons(); selectRegion(id); enterEditMode();
    }}
    function onKeyUp(evt){ if(evt.code === 'Space') spaceDown = false; }

    // ---- Drag vertex ----
    function startDragVertex(circleEl){
        draggingVertex = circleEl;
        document.addEventListener('mousemove', dragVertex);
        document.addEventListener('mouseup', endDragVertex);
        // snapshot for undo
        pushUndo('drag-vertex-start');
    }
    function dragVertex(ev){
        if(!draggingVertex) return;
        const svgP = clientToView(ev);
        let nx = svgP.x, ny = svgP.y;
        // if snap enabled, attempt to snap to nearest edge
        if(snapEnabled && edgePoints && edgePoints.length>0){
            const candidate = nearestEdge(nx, ny, SNAP_RADIUS);
            if(candidate){ nx = candidate.x; ny = candidate.y; }
        }
        draggingVertex.setAttribute('cx', nx); draggingVertex.setAttribute('cy', ny);
        const rid = draggingVertex.dataset.region; const idx = Number(draggingVertex.dataset.index);
        const region = data.regions.find(r=>r.id===rid);
        if(region){
            region.points[idx] = [nx, ny];
            const poly = polygonsGroup.querySelector(`polygon[data-id="${rid}"]`); if(poly) poly.setAttribute('points', region.points.map(p=>p.join(',')).join(' '));
        }
    }
    function endDragVertex(){
        if(draggingVertex){
            document.removeEventListener('mousemove', dragVertex);
            document.removeEventListener('mouseup', endDragVertex);
            draggingVertex = null;
            pushUndo('drag-vertex-end');
        }
    }

    // ---- Move region ----
    function startMoveRegion(evt, regionId){
        movingRegion = true;
        const p = clientToView(evt);
        moveStart = {x:p.x, y:p.y};
        const region = data.regions.find(r=>r.id===regionId);
        if(region) moveOriginalPoints = region.points.map(pp=>[pp[0], pp[1]]);
        // record snapshot before move
        pushUndo('start-move-region');
    }

    // ---- Snap & refine ----
    document.getElementById('snapToggle').addEventListener('click', ()=>{
        snapEnabled = !snapEnabled; document.getElementById('snapToggle').textContent = snapEnabled? 'Snap: On':'Snap: Off';
    });
    document.getElementById('refineBtn').addEventListener('click', ()=>{
        if(!activeRegionId) { alert('Select a region to refine'); return; }
        if(!edgePoints || edgePoints.length===0){ alert('Edge map empty — building edge map first'); buildEdgeMap(); alert('Edge map built; try refine again'); return; }
        pushUndo('refine-vertices');
        const region = data.regions.find(r=>r.id===activeRegionId);
        if(!region) return;
        for(let i=0;i<region.points.length;i++){
            const [x,y] = region.points[i];
            const n = nearestEdge(x,y, SNAP_RADIUS*2);
            if(n) region.points[i] = [n.x, n.y];
        }
        drawPolygons(); selectRegion(activeRegionId);
    });

    // Auto-trace: best-effort contour from strong edge pixels inside polygon
    document.getElementById('autotraceBtn').addEventListener('click', ()=>{
        if(!activeRegionId) { alert('Select a region to auto-trace'); return; }
        if(!edgePoints || edgePoints.length===0){ alert('Edge map empty — building edge map first'); buildEdgeMap(); alert('Edge map built; try auto-trace again'); return; }
        const region = data.regions.find(r=>r.id===activeRegionId);
        if(!region) return;
        pushUndo('autotrace');
        // sample edge points inside polygon bounding box then compute convex hull-like ordering (alpha shape would be better)
        const minX = Math.min(...region.points.map(p=>p[0])), maxX = Math.max(...region.points.map(p=>p[0]));
        const minY = Math.min(...region.points.map(p=>p[1])), maxY = Math.max(...region.points.map(p=>p[1]));
        // pick edge points within bbox and inside polygon
        const candidates = edgePoints.filter(p => p.x>=minX && p.x<=maxX && p.y>=minY && p.y<=maxY && pointInPolygon([p.x,p.y], region.points));
        if(candidates.length < 6){ alert('Not enough edge points inside region for a reliable trace'); return; }
        // reduce points to AUTO_TRACE_RESAMPLE by ordering with angle around centroid
        const cx = candidates.reduce((s,c)=>s+c.x,0)/candidates.length;
        const cy = candidates.reduce((s,c)=>s+c.y,0)/candidates.length;
        candidates.sort((a,b)=>Math.atan2(a.y-cy,a.x-cx) - Math.atan2(b.y-cy,b.x-cx));
        const step = Math.max(1, Math.floor(candidates.length / AUTO_TRACE_RESAMPLE));
        const traced = candidates.filter((_,i)=>i%step===0).map(p=>[p.x,p.y]);
        // if traced too few points, fallback to convex hull of candidates
        if(traced.length < 6){
            const hull = convexHull(candidates.map(p=>[p.x,p.y]));
            region.points = hull;
        } else {
            // accept traced as region points
            region.points = traced;
        }
        drawPolygons(); selectRegion(activeRegionId);
    });

    // ---- Utilities: pointInPolygon, convexHull ----
    function pointInPolygon(pt, vs) {
        // ray-casting algorithm
        const x = pt[0], y = pt[1];
        let inside = false;
        for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
            const xi = vs[i][0], yi = vs[i][1];
            const xj = vs[j][0], yj = vs[j][1];
            const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi + 1e-12) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }

    // convex hull monotone chain
    function convexHull(points){
        if(points.length <= 3) return points.slice();
        points = points.map(p => ({x:p[0], y:p[1]})).sort((a,b)=> a.x===b.x ? a.y-b.y : a.x-b.x);
        const cross = (o,a,b) => (a.x-o.x)*(b.y-o.y) - (a.y-o.y)*(b.x-o.x);
        const lower = [];
        for(const p of points){
            while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop();
            lower.push(p);
        }
        const upper = [];
        for(let i=points.length-1;i>=0;i--){
            const p = points[i];
            while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop();
            upper.push(p);
        }
        upper.pop(); lower.pop();
        const hull = lower.concat(upper).map(p=>[p.x,p.y]);
        return hull;
    }

    // ---- nearestEdge helper (same as earlier) ----
    function nearestEdge(x,y, radius=SNAP_RADIUS){
        if(!edgePoints || edgePoints.length===0) return null;
        const r2 = radius*radius; let best=null, bd=Infinity;
        for(let i=0;i<edgePoints.length;i++){
            const p = edgePoints[i];
            const dx = p.x - x, dy = p.y - y;
            const d2 = dx*dx + dy*dy;
            if(d2 < bd && d2 <= r2){ bd=d2; best=p; }
        }
        return best;
    }

    // ---- Undo/Redo UI ----
    document.getElementById('undoBtn').addEventListener('click', ()=>undo());
    document.getElementById('redoBtn').addEventListener('click', ()=>redo());

    // ---- Pan toggle UI ----
    document.getElementById('togglePanBtn').addEventListener('click', ()=>{
        panToggleOn = !panToggleOn;
        document.getElementById('togglePanBtn').textContent = panToggleOn? 'Pan: On' : 'Pan: Off';
    });

    // ---- Edge map build initially (async) ----
    async function initEdgeAndUI(){
        await buildEdgeMap();
        // load regions.json if present
        await tryLoadJson();
        createSvg();
        drawPolygons();
        applyTransform();
        updateUndoRedoButtons();
    }
    initEdgeAndUI();

    // ---- Load regions.json (like before) ----
    async function tryLoadJson(){
        try{
            const resp = await fetch('regions.json', {cache:'no-store'});
            if(!resp.ok) throw new Error('no local regions.json');
            const json = await resp.json();
            if(json && json.regions) data = json; else data = {meta:{source:'fetched'}, regions: json};
            console.log('Loaded regions.json from local folder');
        }catch(e){
            console.log('regions.json not found — using fallback');
            data = {
                meta:{source:'fallback', scale:VIEW_SIZE},
                regions:[
                    {"id":"anambra-west","name":"Anambra West","desc":"<p>Anambra West</p>","points":[[65,120],[160,110],[195,95],[220,120],[190,200],[170,260],[120,280],[86,250],[70,200]]},
                    {"id":"anambra-east","name":"Anambra East","desc":"<p>Anambra East</p>","points":[[205,140],[264,132],[300,160],[280,210],[240,230],[210,190]]},
                    {"id":"ihiala","name":"Ihiala","desc":"<p>Ihiala</p>","points":[[100,460],[160,420],[190,460],[170,520],[130,540],[90,520]]}
                ]
            };
        }
    }

    // ---- save changes / JSON load button support (same as earlier) ----
    document.getElementById('downloadJsonBtn').addEventListener('click', ()=>{
        const payload = {meta:{source:'export',scale:VIEW_SIZE}, regions:data.regions};
        const blob = new Blob([JSON.stringify(payload,null,2)], {type:'application/json'});
        const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='regions.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });

    // ---- apply transformGroup transform for pan/zoom ----
    function applyTransform(){ if(transformGroup) transformGroup.setAttribute('transform', `translate(${pan.x},${pan.y}) scale(${scale})`); }

    // ---- utilities: nearestEdge already defined above ----

    // ---- Final note: some UI wiring for name/desc editing and region list selection ----
    document.getElementById('saveChangesBtn').addEventListener('click', ()=>{
        if(!activeRegionId){ alert('Select a region to save'); return; }
        pushUndo('edit-meta');
        const r = data.regions.find(rr=>rr.id===activeRegionId);
        if(!r) return;
        r.name = document.getElementById('regionName').value;
        r.desc = document.getElementById('regionDesc').value;
        drawPolygons(); selectRegion(activeRegionId);
    });

    document.getElementById('addRegionBtn').addEventListener('click', ()=>{
        pushUndo('add'); const id='region-'+Math.random().toString(36).slice(2,8);
        data.regions.push({id,name:'New region',desc:'<p>Describe</p>', points:[[300,300],[360,300],[360,360],[300,360]]});
        drawPolygons(); selectRegion(id); enterEditMode();
    });

    // small helper to update vertices indices when drawing
    function refreshVertexIndices(){
        Array.from(verticesGroup.querySelectorAll('circle')).forEach(c=>{
            const rid=c.dataset.region; const region = data.regions.find(r=>r.id===rid);
            if(region){
                // find index by matching coordinates (approx)
                const cx = parseFloat(c.getAttribute('cx')), cy = parseFloat(c.getAttribute('cy'));
                let idx = region.points.findIndex(pp => Math.abs(pp[0]-cx)<0.001 && Math.abs(pp[1]-cy)<0.001);
                if(idx < 0) idx = 0;
                c.dataset.index = idx;
            }
        });
    }

    // ensure vertices indices updated after each draw
    const originalDrawPolygons = drawPolygons;
    drawPolygons = function(){
        originalDrawPolygons();
        refreshVertexIndices();
    };

    // Done: the file is feature-rich. Enjoy!

</script>
</body>
</html>
